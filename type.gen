dofile("show.lua")

--HERE Enums
Goal = {
	"NewHub", -- open file
	"ThdHub",
	"CfgHub", -- set pid and forward
	"AppHub", -- set pid and forward
	"HubThd", -- lock write forwarded
	"AppThd", -- lock append forwarded
	"ThdThd", -- file change notify
	"HubCfg", -- identify file change
	"ThdErr", -- close and report
	"HubErr", -- report and exit
}
Level = {
	"Stock",
	"First",
	"Assign",
	"Link",
	"Wave",
	"Timer",
	"Audio",
}
Flow = {
	"Sched",
	"Back",
	"Peek",
	"Poke",
	"Store",
	"Load",
}
Memory = {
	"Indexz", -- fetch buffer indices
	"Bringupz", -- fetch buffer verticse
	"Imagez", -- facet decorations
	"Getintz", -- per fragment read
	"Getoldz", -- per fragment read
	"Setintz", -- per fragment write
	"Setoldz", -- per fragment write
	"Uniformz", -- references into arrays
	"Matrixz", -- transformations
	"Trianglez", -- indices of vertices of facet
	"Numericz", -- distances of plane above selected base
	"Vertexz", -- intersection of backlinked planes
	"Basisz", -- base for each dimension
	"Drawz", -- draw range info
	"Instrz", -- little vulkan language
	"Stringz", -- string memory
	"Machinez", -- state machine lines
	"Expressz", -- expression library
	"Kernelz", -- inflight transformations
	"Configurez", -- configure to value
}
Resrc = { -- per variation of BaseState
	"SwapRes",
	"PipeRes",
	"IndexRes",
	"BringupRes",
	"ImageRes",
	"WrapRes",
	"PierceRes",
	"RelateRes",
	"UniformRes",
	"MatrixRes",
	"TriangleRes",
	"NumericRes",
	"VertexRes",
	"BasisRes",
	"ChainRes",
	"DrawRes",
	"BindRes",
}
Micro = { -- what runs on gpu
	"MicroTest", -- fetch and texture
	"MicroDebug", -- uint per pixel
	"MicroFill", -- fill with uniform
	"MicroDisplay", -- decorate vec4
	"MicroCompute", -- decorate uvec4
	"MicroPierce", -- pierced triangle
	"MicroDepth", -- fixed point
	"MicroDisp", -- indexed vertices
	"MicroComp", -- decorate uvec4
	"MicroPrce", -- pierced triangle
	"MicroDpth", -- fixed point
}
Decor = { -- fragment shader graph operation
	"MoveDec", -- move only
	"DotDec", -- dot product
	"CrossDec", -- cross product
	"PlusDec", -- numwise sum
	"MinusDec", -- numwise difference
	"TimesDec", -- numwise product
	"OverDec", -- numwise quotient
	"PlaneDec", -- construct plane
	"AboveDec", -- jump condition
	"WriteDec", -- write output
}
Swizzle = { -- fragment shader operand selector
	"PointSwz", -- comparison point
	"PlaneSwz", -- constructed plane
	"Corner0Swz", -- construct point
	"Corner1Swz", -- construct point
	"Conrer2Swz", -- construct point
	"BufferSwz", -- located feedback
	"ColorSwz", -- color suggestion
	"CoordSwz", -- fragment location
	"IndexSwz", -- primitive index
	"TextureSwz", -- texture color
	"RelateSwz", -- closeby indices
	"NormalSwz", -- surface normal
	"UniformSwz", -- uniform value
}
Constant = {
	"MicroCon",
	"MemoryCon",
	"ResrcCon",
}
Reloc = {
	"ResizeLoc",
	"ReformLoc",
	"BeforeLoc", -- like Acquire
	"MiddleLoc", -- like Draw
	"AfterLoc", -- like Present
	-- "Sync5Loc",
	-- "Sync6Loc",
}
Extent = { -- resource initialization done on gpu thread
	"InitExt", -- leave in initial state; don't resize
	"IntExt", -- resize to base,size
	"FormExt", -- reform to format
	"ExtentExt", -- resize to 2d vk extent
	"FillExt", -- record fill value
	"MicroExt", -- resize to micro enum
	"ResrcExt", -- resize to bind enum
	"TrueExt", -- resize once for side effects
	"FalseExt", -- resize every time for side effects
}
Request = {
	"BothReq", -- call resize if changed, and call setup
	"LockReq", -- call setup
	"SizeReq", -- call resize if changed
	"NullReq", -- call resize if changed, call and ignore setup
	"ExclReq", -- call resize and setup if changed
}
Phase = {
	"IndexPhs", -- fetch indirection
	"FetchPhs", -- fetch buffer
	"UniformPhs", -- uniform buffer
	"StoragePhs", -- storage buffer
	"RelatePhs", -- feedback buffer
	"SamplePhs", -- texture buffer
	"PipePhs", -- pipeline structure
	"FramePhs", -- display buffer
	"SwapPhs", -- display queue
	"RenderPhs", -- frame buffer
}
Render = { -- VkFormat
	"VecFrm",
	"UvecFrm",
	"UintFrm",
	"SfloatFrm",
	"SrgbFrm",
}
Format = {
	"ImageFrm", -- ExclReq FormExt base(implied:src) size(implied:dst) (undefined to readonly)
	"WonlyFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (readonly to dst)
	"RonlyFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (dst to readonly)
	"PierceFrm", -- ExclReq FormExt base(implied:src) size(implied:dst) (undefined to color)
	"PeekFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (color to src)
	"SourceFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (src to color)
	"PokeFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (color to dst)
	"DestFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (dst to color)
	"RelateFrm", -- ExclReq FormExt base(implied:src) size(implied:dst) (undefined to src)
	"RdwrFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (src to dst)
	"WrrdFrm", -- BothReq FormExt base(implied:src) size(implied:dst) (dst to src)
	"ExtentFrm", -- SizeReq ExtentExt base(given:width) size(given:height)
	"SizeFrm", -- SizeReq IntExt base(from center) size(from center)
	"WholeFrm", -- BothReq IntExt ptr(from center) idx(from center) siz(from center) base(implied: same as idx) size(implied: same as siz)
	"LockFrm", -- LockReq IntExt ptr(from center) idx(from center) siz(from center)
	"ResrcFrm", -- SizeReq ResrcExt resrc
	"PipeFrm", -- SizeReq MicroExt base(same as resource index)
	"MicroFrm", -- BothReq MicroExt idx(first vertex shader index) siz(number of vertex shader indices) base(which shader set)
	"NullFrm", -- NullReq TrueExt
	"FalseFrm", -- SizeReq FalseExt(always resize)
	"TrueFrm", -- SizeReq TrueExt(resize once)
}
Instr = {
	"NewDerIns", -- advance before push to thread
	"OldDerIns", -- advance an oldest after fence
	"GetDerIns", -- advance the oldest after fence
	"NidDerIns", -- before newest indicated instance
	"OidDerIns", -- after an oldest indicated instance
	"GidDerIns", -- after the oldest indicated instance
	"IdxDerIns", -- process a particular instance
	"WrlDeeIns", -- increment write lock in current
	"RdlDeeIns", -- increment read lock in current
	"WidDeeIns", -- increment write in indicated
	"RidDeeIns", -- increment read in indicated
	"IdxDeeIns", -- increment read lock in indexed
	"SetTagIns", -- set tag value in given quality
	"MovTagIns", -- change tag of newest of handle
	"ResIncIns", -- include instructions from Resrc
	"MemIncIns", -- include instructions from Memory
	"MicIncIns", -- include instructions from Micro
}
Quality = { -- quality of service tags for *TagIns
	"SnumQua", -- sequence number to depend on resources that depend on same original resource
	"RbutQua", -- to use resource only after it progresses
	"RsizQua", -- to resize resources only once
	"RuseQua", -- resource use qualifier
}
Reuse = { -- RuseQua per variation of Resrc
	"TexUse", -- texture from cpu to gpu
	"FdbUse", -- feedback from gpu to gpu
	"GetUse", -- from debug gpu to cpu
	"SetUse", -- from cpu to debug gpu
	"PieUse", -- from gpu pierce to cpu
	"DptUse", -- from gpu depth to cpu
}
Default = { -- for value, interpret constant array as
	"TrivDef", -- builtin
	"BackDef", -- prior
	"GiveDef", -- given
}
Configure = {
	"CenterMem", -- staged field
	"CenterSiz",
	"CenterIdx",
	"CenterSlf",
	"CenterPtr", -- whether staged
	"ArgumentInp", -- staged field
	"ArgumentOut",
	"RegisterCall", -- start wake stop
	"RegisterMain", -- main machine center
	"RegisterOpen", -- thread mask
	"RegisterShow", -- commandline mask
	"RegisterPlan", -- testing plan
	"RegisterPoll", -- poll microseconds
	"RegisterExit", -- sortof exit status
	"RegisterPass", -- pass center mask
	"RegisterFail", -- fail center mask
	"RegisterSave", -- pass or fail mask
	"RegisterWake", -- thread interrupts
	"RegisterAble", -- interrupts enable
	"RegisterTime", -- wake time delay
	"RegisterStrq", -- num strings in queue
	"RegisterEval", -- expression center index
	"UniformAll", -- which subject to use
	"UniformOne", -- which element to use
	"UniformIdx", -- which plane to manipulate
	"UniformUse", -- which basis to use
	"UniformTri", -- base of triangles
	"UniformNum", -- base of numerics
	"UniformVtx", -- base of vertices
	"UniformMat", -- base of matrices
	"UniformBas", -- base of basises
	"UniformMod", -- value to fill
	"UniformWid", -- width of image
	"UniformHei", -- height of image
	"PressKey",
	"ManipFixed",
	"ManipLeft",
	"ManipBase",
	"ManipAngle",
	"ClickLeft",
	"ClickBase",
	"ClickAngle",
	"FixedLeft",
	"FixedBase",
	"FixedDeep",
	"NormalLeft",
	"NormalBase",
	"NormalDeep",
	"FocalDepth",
	"FocalSlope",
	-- following are scratch registers
	"ConstantDescrs",
	"ConstantMicros",
	"ConstantFrames",
	"ConstantImages",
	"ConstantPiercs",
	"ConstantInstrs",
	"ConstantResrcs",
	"ConstantHandls",
}
Transfer = {
	"Stage", -- center fields to configure
	"Tsage", -- configure to center fields
	"Force", -- machine to configure
	"Eval", -- call datxEval to rmw center
	"Void", -- discard result of datxEval
	"Argv", -- hide and process
	-- identity I
	-- current manipulation C
	-- Kernel.saved T
	-- Kernel.local L
	-- Kernel.sent S
	-- Kernel.global G
	-- Matrix M
	"Comp", -- T = C; M = GSLT
	"Form", -- L = LTC'; T = C
	"Send", -- M = L; S = SL; L = I
	"Self", -- G = GM; S = M'S
	"Glob", -- G = GM
	"Bopy", -- memory to memory
	"Copy", -- center to resource
	"Dopy", -- center to center
	"Popy", -- queue to center
	"Qopy", -- center to queue
	"Goto", -- jump to value
	"Jump", -- skip by value
	"Nest", -- nest by value
}
ArgvArg = {
	"ArgvSrc",
}
CompArg = {
	"CompSrc",
	"CompSrcSub",
	"CompDst",
	"CompDstSub",
}
FormArg = {
	"FormSrc",
	"FormSrcSub",
}
SendArg = {
	"SendSrc",
	"SendSrcSub",
	"SendDst",
	"SendDstSub",
}
SelfArg = {
	"SelfSrc",
	"SelfSrcSub",
	"SelfDst",
	"SelfDstSub",
}
GlobArg = {
	"GlobSrc",
	"GlobSrcSub",
	"GlobDst",
	"GlobDstSub",
}
BopyArg = {
	"BopySrc",
	"BopySrcSub",
	"BopyDst",
	"BopyDstSub",
	"BopyCount",
}
CopyArg = {
	"CopySrc",
}
DopyArg = {
	"DopySrc",
	"DopyDst",
}
PopyArg = {
	"PopyDst",
}
QopyArg = {
	"QopySrc",
}
Plan = { -- which test to run
	"Bringup",
	-- Bootstrap detects no arguments through RegisterShow, sets RegisterPlan to Bringup.
	-- initPlan starts test and gpu threads, and directs gpu events to test thread.
	-- initTest sets up gpu buffers for fetched tutorial points.
	-- planeTest issues matrix buffer updates and draw requests as fast as possible.
	-- initPlan starts machine and time threads, and direct time events to machine.
	-- planeMachine prints primitive index from peek pass events, and time from time events.
	"Builtin",
	-- Bootstrap detects arguments but no Argument, sets RegisterPlan to Builtin.
	-- similar to Bringup, except use indexed instead of fetched points.
	-- similar to Bringup, except matrix for planeTest copied to gpu by planeMachine.
	-- similar to Bringup, except matrix for planeTest adjusted through
	-- Comp Form Send Self Glob.
	"Regress",
	-- Bootstrap detects arguments and Argument, sets RegisterPlan to Regress.
	-- no test or time thread, just gpu machine select.
	-- use arguments to load machine, then reproduce Builtin from pipe from lua.
	"Release",
	-- Bootstrap detects Argument only, sets RegisterPlan to Release.
	-- similar to Regress, except pipe and user processed by builtin machine.
}
Action = { -- what input does
	"Indicate", -- move to new piere point
	"Collect", -- identify subpolytope
	"Manipulate", -- apply transformation
	"Refine", -- add boundaries
	"Additive", -- add regions
	"Subtractive", -- remove regions
}
Fixed = { -- how motion interpreted
	"Mouse", -- how many fixed
	"Roller",
	"Slide", -- how changed
	"Rotate",
	"Scale",
	"Cursor", -- what fixed
	"Focal",
	"Ortho",
	"Normal",
}
Thread = { -- separate threads
	"PipeThd",
	"StdioThd",
	"MachThd",
	"FenceThd",
	"TimeThd",
	"TestThd",
}
Mask = { -- signals between threads
	"FnceMsk", -- fence thread wakeup
	"SlctMsk", -- pipe thread wakeup
	"CnslMsk", -- stdio thread wakeup
	"TimeMsk", -- time thread wakeup
	"PassMsk", -- passing copy callback
	"FailMsk", -- failing copy callback
	"DropMsk", -- response without request
	"PollMsk", -- every glfw wakeup
	"PrssMsk", -- glfw key pressed
	"SizeMsk", -- glfw window resized
	"MoveMsk",
	"ClckMsk",
	"RollMsk",
	"UnifMsk",
}
Emerg = { -- topology state
	"Planes", -- Scalar -- [Plane] -- per boundary
	"Halfs", -- Nested -- Space -- per boundary
	"Coins", -- Listed -- [[Boundary]] -- per vertex
	"Points", -- Scalar -- [Point] -- per vertex
	"Facets", -- Listed -- [[Vertex]] -- per facet vertex triplets
	"Subsets", -- Int -- [Region] -- in context of space
}
Valid = {
	"Toread", -- request for response
	"Toresp", -- response to request
	"Towrite", -- overwrite given element
	"Toadd", -- additively change
	"Tosub", -- subtractively change
}
Stream = { -- commandline process pipe connector
	"Fanout", -- write from readable pipe round robin to one of several pipes
	"Combine", -- write to pipe from expression if any of several expression values change
	"Buffer", -- set expression value from pipe
	"Execute", -- start a filter between the last and next pipe
}
Operate = { -- little language expressions
	"AddOp",
	"SubOp",
	"MulOp",
	"DivOp",
	"RemOp",
	"BitOp",
	"CmpOp",
	"CndOp", -- touring machine
	"NonOp", -- discard list of values
	"RetOp", -- config from callback
	"TopOp", -- blocking ret callback
	"SetOp", -- callback with config
	"WosOp", -- callback setbits config
	"WocOp", -- callback clearbits config
	"RawOp", -- callback read and clear config
	"ValOp", -- value from lookup
	"SavOp", -- value for lookup
	"SrcOp", -- push value
	"DstOp", -- peek value
	"PopOp", -- pop value
	"RexOp", -- regex sugar
	"IrxOp", -- irrex sugar
	"GetOp", -- string from callback
	"PutOp", -- callback with string
	"FldOp", -- fields to struct
	"ExtOp", -- fields from struct
	"TimOp", -- time since process start
	"CstOp", -- cast first to type of second
	"ImmOp", -- built in value
	"IntOp", -- ImmOp sugar
	"StrOp", -- ImmOp sugar
	"EndOp", -- endline sugar
}
Compare = { -- little language comparisons
	-- Less Equal More
	-- Open Closed
	"LOCmp",
	"LCCmp",
	"EOCmp",
	"ECCmp",
	"MOCmp",
	"MCCmp",
	"ReCmp", -- regular expression
	"IrCmp", -- irregular expression
}
Bitwise = { -- little language bitwise
	"AndBit",
	"OrBit",
	"XorBit",
	"NandBit",
	"NorBit",
	"NxorBit",
	"ShlBit",
	"FnsBit",
}
Order = { -- ireg expression operators
	"ChrOrd",
	"PreOrd",
	"PostOrd",
	"PermOrd",
	"ForkOrd",
	"BeginOrd",
}
Program = { -- process type in standard commandline argument
	"Filez", -- Persist
	"Holez", -- Persist
	"Linez", -- Event
	"Planez", -- Center
	"Spacez", -- Change
	"Sidez", -- Persist gui
	"Framez", -- video little language
	"Sharez", -- Valve
}
Tag = { -- type of data piped between processes
	"Persistz", -- file hole side
	"Eventz", -- line
	"Centerz", -- plane
	"Changez", -- space
	-- video little language -- frame
	"Valvez", -- share
}
--HERE Constants
ResrcStride = {
	{"Resrc","BringupRes","Int","48"},
}
ResrcOffset = {
	{"Resrc","BringupRes","Int","0","Int","0"},
	{"Resrc","BringupRes","Int","1","Int","16"},
	{"Resrc","BringupRes","Int","2","Int","32"},
}
ResrcFormat = {
	{"Resrc","BringupRes","Int","0","Render","VecFrm"},
	{"Resrc","BringupRes","Int","1","Render","VecFrm"},
	{"Resrc","BringupRes","Int","2","Render","UvecFrm"},
}
ResrcElement = {
	{"Resrc","BringupRes","Int","0","Int","4"},
	{"Resrc","BringupRes","Int","1","Int","4"},
	{"Resrc","BringupRes","Int","2","Int","4"},
}
-- Resrc is sufficient for buffer structure, but binding info depend on Micro
MicroBinding = {
	{"%(function fnc (lst) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(v) else return v end end end\
	function gnc (lst,oth) for i,v in ipairs(lst) do for j,w in ipairs(oth) do if i ~= #lst or j~= #oth then coroutine.yield(v) else return v end end end end\
	function hnc (lst,num) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(i+num-1) else return i+num-1 end end end\
	function cat (one,oth) local max = #one; for i,v in ipairs(oth) do max = max + 1; one[max] = v end return one end\
	mia = {\"MicroTest\"}\
	mib = {\"MicroDebug\"}\
	mic = {\"MicroDisplay\"}\
	mid = {\"MicroCompute\",\"MicroPierce\",\"MicroDepth\"}\
	mie = {\"MicroDisp\"}\
	mif = {\"MicroComp\",\"MicroPrce\",\"MicroDpth\"}\
	res = {\"UniformRes\",\"MatrixRes\", \"IndexRes\",\"BringupRes\",\"PipeRes\"}\
	phs = {\"UniformPhs\",\"UniformPhs\",\"IndexPhs\",\"FetchPhs\",  \"PipePhs\"}\
	bns = {\"0\",         \"1\",         \"0\",       \"0\",         \"0\"      }\
	rep = {\"SwapRes\",\"ChainRes\",\"ImageRes\" } req = {\"PierceRes\"}\
	php = {\"SwapPhs\",\"FramePhs\",\"SamplePhs\"} phq = {\"RenderPhs\"}\
	bnp = {\"0\",      \"0\",       \"7\"        } bnq = {\"0\"        }\
	rea = cat(rep,res) pha = cat(php,phs) bna = cat(bnp,bns)\
	reb = cat(req,res) phb = cat(phq,phs) bnb = cat(bnq,bns)\
	res = {\"UniformRes\",\"MatrixRes\", \"BasisRes\",  \"TriangleRes\",\"NumericRes\",\"VertexRes\", \"PipeRes\"}\
	phs = {\"UniformPhs\",\"UniformPhs\",\"StoragePhs\",\"StoragePhs\", \"StoragePhs\",\"StoragePhs\",\"PipePhs\"}\
	bns = {\"0\",         \"1\",         \"2\",         \"3\",          \"4\",         \"5\",         \"0\"      }\
	rep = {\"SwapRes\",\"ChainRes\",\"RelateRes\"} req = {\"PierceRes\"}\
	php = {\"SwapPhs\",\"FramePhs\",\"RelatePhs\"} phq = {\"RenderPhs\"}\
	bnp = {\"0\",      \"0\",       \"6\"        } bnq = {\"0\"        }\
	rec = cat(rep,res) phc = cat(php,phs) bnc = cat(bnp,bns)\
	red = cat(req,res) phd = cat(phq,phs) bnd = cat(bnq,bns)\
	res = {\"UniformRes\",\"MatrixRes\", \"TriangleRes\",\"VertexRes\", \"PipeRes\"}\
	phs = {\"UniformPhs\",\"UniformPhs\",\"StoragePhs\", \"StoragePhs\",\"PipePhs\"}\
	bns = {\"0\",         \"1\",         \"3\",          \"5\",         \"0\"      }\
	rep = {\"SwapRes\",\"ChainRes\",\"RelateRes\"} req = {\"PierceRes\"}\
	php = {\"SwapPhs\",\"FramePhs\",\"RelatePhs\"} phq = {\"RenderPhs\"}\
	bnp = {\"0\",      \"0\",       \"6\"        } bnq = {\"0\"        }\
	ree = cat(rep,res) phe = cat(php,phs) bne = cat(bnp,bns)\
	ref = cat(req,res) phf = cat(phq,phs) bnf = cat(bnq,bns)\
	return \"Micro\")","%(return gnc(mia,rea))","Int","%(return hnc(rea,0))","Resrc","%(return fnc(rea))"},
	{"Micro","%(return gnc(mia,pha))","Int","%(return hnc(pha,0))","Phase","%(return fnc(pha))"},
	{"Micro","%(return gnc(mia,bna))","Int","%(return hnc(bna,0))","Int","%(return fnc(bna))"},
	{"Micro","%(return gnc(mib,reb))","Int","%(return hnc(reb,0))","Resrc","%(return fnc(reb))"},
	{"Micro","%(return gnc(mib,phb))","Int","%(return hnc(phb,0))","Phase","%(return fnc(phb))"},
	{"Micro","%(return gnc(mib,bnb))","Int","%(return hnc(bnb,0))","Int","%(return fnc(bnb))"},
	{"Micro","%(return gnc(mic,rec))","Int","%(return hnc(rec,0))","Resrc","%(return fnc(rec))"},
	{"Micro","%(return gnc(mic,phc))","Int","%(return hnc(phc,0))","Phase","%(return fnc(phc))"},
	{"Micro","%(return gnc(mic,bnc))","Int","%(return hnc(bnc,0))","Int","%(return fnc(bnc))"},
	{"Micro","%(return gnc(mid,red))","Int","%(return hnc(red,0))","Resrc","%(return fnc(red))"},
	{"Micro","%(return gnc(mid,phd))","Int","%(return hnc(phd,0))","Phase","%(return fnc(phd))"},
	{"Micro","%(return gnc(mid,bnd))","Int","%(return hnc(bnd,0))","Int","%(return fnc(bnd))"},
	{"Micro","%(return gnc(mie,ree))","Int","%(return hnc(ree,0))","Resrc","%(return fnc(ree))"},
	{"Micro","%(return gnc(mie,phe))","Int","%(return hnc(phe,0))","Phase","%(return fnc(phe))"},
	{"Micro","%(return gnc(mie,bne))","Int","%(return hnc(bne,0))","Int","%(return fnc(bne))"},
	{"Micro","%(return gnc(mif,ref))","Int","%(return hnc(ref,0))","Resrc","%(return fnc(ref))"},
	{"Micro","%(return gnc(mif,phf))","Int","%(return hnc(phf,0))","Phase","%(return fnc(phf))"},
	{"Micro","%(return gnc(mif,bnf))","Int","%(return hnc(bnf,0))","Int","%(return fnc(bnf))"},
	{"Micro","MicroFill","Int","0","Resrc","PipeRes"},
	{"Micro","MicroFill","Int","0","Phase","PipePhs"},
	{"Micro","MicroFill","Int","0","Int","0"},
	{"Micro","MicroFill","Int","1","Resrc","UniformRes"},
	{"Micro","MicroFill","Int","1","Phase","UniformPhs"},
	{"Micro","MicroFill","Int","1","Int","0"},
	{"Micro","MicroFill","Int","2","Resrc","RelateRes"},
	{"Micro","MicroFill","Int","2","Phase","RenderPhs"},
	{"Micro","MicroFill","Int","2","Int","0"},
}
VertexFile = {
	{"Micro","MicroTest","Str","vertexTestG"},
	{"Micro","MicroDebug","Str","vertexDebugG"},
	{"Micro","MicroFill","Str","vertexFillG"},
	{"Micro","MicroDisplay","Str","vertexDisplayG"},
	{"Micro","MicroCompute","Str","vertexComputeG"},
	{"Micro","MicroPierce","Str","vertexPierceG"},
	{"Micro","MicroDepth","Str","vertexDepthG"},
	{"Micro","MicroDisp","Str","vertexDispG"},
	{"Micro","MicroComp","Str","vertexCompG"},
	{"Micro","MicroPrce","Str","vertexPrceG"},
	{"Micro","MicroDpth","Str","vertexDpthG"},
}
FragmentFile = {
	{"Micro","MicroTest","Str","fragmentTestG"},
	{"Micro","MicroDebug","Str","fragmentDebugG"},
	{"Micro","MicroFill","Str","fragmentFillG"},
	{"Micro","MicroDisplay","Str","fragmentDisplayG"},
	{"Micro","MicroCompute","Str","fragmentComputeG"},
	{"Micro","MicroPierce","Str","fragmentPierceG"},
	{"Micro","MicroDepth","Str","fragmentDepthG"},
	{"Micro","MicroDisp","Str","fragmentDispG"},
	{"Micro","MicroComp","Str","fragmentCompG"},
	{"Micro","MicroPrce","Str","fragmentPrceG"},
	{"Micro","MicroDpth","Str","fragmentDpthG"},
}
-- queue blobs are per Memory Resrc or Micro
-- Micro queue blobs are decoupled from bindings per Micro,
-- because there can be different queue blobs with same Micro
MemoryIns = {
	-- n==0: departures from OldDerIns,Resrcs,Memorys,Micros,MiddleLoc,WholeFrm,Qualitys,Reuses
	-- n>0: departures from n-1
	{"%(mem={\"Imagez\",\"Setoldz\",\"Getoldz\",\"Setintz\",\"Getintz\"}"..
	"res={\"ImageRes\",\"PierceRes\",\"PierceRes\",\"RelateRes\",\"RelateRes\"}"..
	"ret={\"TexUse\",\"SetUse\",\"GetUse\",\"SetUse\",\"GetUse\"}"..
	"siz={\"ExtentFrm\",\"ExtentFrm\",\"ExtentFrm\",\"ExtentFrm\",\"ExtentFrm\"}"..
	"ref={\"ImageFrm\",\"PierceFrm\",\"PierceFrm\",\"PierceFrm\",\"PierceFrm\"}"..
	"bef={\"WonlyFrm\",\"PokeFrm\",\"PeekFrm\",\"PokeFrm\",\"PeekFrm\"}"..
	"mid={\"WholeFrm\",\"WholeFrm\",\"WholeFrm\",\"WholeFrm\",\"WholeFrm\"}"..
	"aft={\"RonlyFrm\",\"DestFrm\",\"SourceFrm\",\"DestFrm\",\"SourceFrm\"}"..
	"function fnc (lst) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(v) else return v end end end;"..
	"function rng (bas,max) for i = bas,max do if i ~= max then coroutine.yield(i) else return i end end end;"..
	"function rnc (lst,bas,max) for i,v in ipairs(lst) do for j = bas,max do if (i ~= #lst) or (j ~= max) then coroutine.yield(v) else return v end end end end;"..
	"return \"Memory\")","%(return fnc(mem))","Int","0","Instr","SetTagIns"},
	{"Memory","%(return fnc(mem))","Int","0","Resrc","%(return fnc(res))"},
	{"Memory","%(return fnc(mem))","Int","0","Quality","RuseQua"},
	{"Memory","%(return fnc(mem))","Int","0","Reuse","%(return fnc(ret))"},
	{"Memory","%(return fnc(mem))","Int","1","Instr","OldDerIns"},
	{"Memory","%(return fnc(mem))","Int","1","Memory","Memorys"},
	{"Memory","%(return fnc(mem))","Int","1","Micro","Micros"},
	{"Memory","%(return fnc(mem))","Int","1","Reloc","ResizeLoc"},
	{"Memory","%(return fnc(mem))","Int","1","Format","%(return fnc(siz))"},
	{"Memory","%(return fnc(mem))","Int","2","Reloc","ReformLoc"},
	{"Memory","%(return fnc(mem))","Int","2","Format","%(return fnc(ref))"},
	{"Memory","%(return fnc(mem))","Int","3","Reloc","BeforeLoc"},
	{"Memory","%(return fnc(mem))","Int","3","Format","%(return fnc(bef))"},
	{"Memory","%(return fnc(mem))","Int","4","Reloc","MiddleLoc"},
	{"Memory","%(return fnc(mem))","Int","4","Format","%(return fnc(mid))"},
	{"Memory","%(return fnc(mem))","Int","5","Reloc","AfterLoc"},
	{"Memory","%(return fnc(mem))","Int","5","Format","%(return fnc(aft))"},
	{"Memory","%(return rnc(mem,0,3))","Int","%(return rng(0,3))","Default","GiveDef"},
	{"Memory","%(return rnc(mem,0,3))","Int","%(return rng(0,3))","Int","%(return rng(0,3))"},
	{"%(nem = {\"Bringupz\",\"Indexz\",\"Uniformz\",\"Matrixz\",\"Trianglez\",\"Numericz\",\"Vertexz\",\"Basisz\"}\
	ses={\"BringupRes\",\"IndexRes\",\"UniformRes\",\"MatrixRes\",\"TriangleRes\",\"NumericRes\",\"VertexRes\",\"BasisRes\"};\
	return \"Memory\")","%(return fnc(nem))","Int","0","Resrc","%(return fnc(ses))"},
	{"Memory","%(return rnc(nem,0,1))","Int","%(return rng(0,1))","Default","GiveDef"},
	{"Memory","%(return rnc(nem,0,1))","Int","%(return rng(0,1))","Int","%(return rng(0,1))"},
}
MemoryAlt = {
	{"Memory","Matrixz","Int","0","Instr","OldDerIns"},
	{"Memory","Matrixz","Int","0","Resrc","MatrixRes"},
	{"Memory","Matrixz","Int","0","Memory","Memorys"},
	{"Memory","Matrixz","Int","0","Micro","Micros"},
	{"Memory","Matrixz","Int","0","Reloc","MiddleLoc"},
	{"Memory","Matrixz","Int","0","Format","LockFrm"},
	{"Memory","Matrixz","Int","0","Quality","Qualitys"},
	{"Memory","Matrixz","Int","0","Reuse","Reuses"},
	{"Memory","Matrixz","Int","0","Default","GiveDef"},
	{"Memory","Matrixz","Int","0","Int","0"},
	{"Memory","Matrixz","Int","1","Default","GiveDef"},

	{"%(function fnc (lst) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(v) else return v end end end "..
	"function gnc(sub,sup) for i = 1,(#sup//#sub) do count = count + 1; for j = 1,#sub do if (i<(#sup//#sub)) or (j<#sub) then coroutine.yield(count-1) else return (count-1) end end end end "..
	"function rng (bas,max) for i = bas,max do if i ~= max then coroutine.yield(i) else return i end end end "..
	"key={\"Instr\",\"Resrc\",\"Reloc\",\"Reuse\",\"Format\"};"..
	"kez={\"Reloc\",\"Format\"};"..
	"val={\"OldDerIns\",\"PierceRes\",\"ResizeLoc\",\"SetUse\",\"ExtentFrm\"};"..
	"wal={\"ReformLoc\",\"PierceFrm\","..
	"\"BeforeLoc\",\"PokeFrm\","..
	"\"MiddleLoc\",\"WholeFrm\","..
	"\"AfterLoc\",\"DestFrm\"};"..
	"vam={\"OldDerIns\",\"WrapRes\",\"ResizeLoc\",\"GetUse\",\"ResrcFrm\"};"..
	"wam={\"ReformLoc\",\"PierceFrm\","..
	"\"BeforeLoc\",\"PeekFrm\","..
	"\"MiddleLoc\",\"WholeFrm\","..
	"\"AfterLoc\",\"SourceFrm\"};"..
	"count = 0; return \"Memory\")","Matrixz","Int","1","Int","1"},
	{"Memory","Getoldz","Int","%(return gnc(key,val))","%(return fnc(key))","%(return fnc(val))"},
	{"Memory","Getoldz","Int","%(return gnc(kez,wal))","%(return fnc(kez))","%(return fnc(wal))"},
	{"Memory","Getoldz","Int","%(return gnc(key,vam))","%(return fnc(key))","%(return fnc(vam))"},
	{"Memory","Getoldz","Int","%(return gnc(kez,wam))","%(return fnc(kez))","%(return fnc(wam))"},
	{"%(def={\"GiveDef\",\"GiveDef\",".. -- ExtentFrm.base ExtentFrm.size
	"\"GiveDef\",\"GiveDef\",".. -- WholeFrm.idx WholeFrm.siz
	"\"TrivDef\",".. -- ResrcFrm.base
	"\"BackDef\",\"BackDef\"};".. -- WholeFrm.idx WholeFrm.siz
	"arg={0,1,2,3,castResrc(\"PierceRes\"),2,3};"..
	"count = 0; return \"Memory\")","Matrixz","Int","1","Int","1"},
	{"Memory","Getoldz","Int","%(return rng(0,#arg-1))","Default","%(return fnc(def))"},
	{"Memory","Getoldz","Int","%(return rng(0,#arg-1))","Int","%(return fnc(arg))"},

	{"%("..
	"count = 0; return \"Memory\")","Matrixz","Int","1","Int","1"},
	{"Memory","Getintz","Int","0","Instr","MicIncIns"},
	{"Memory","Getintz","Int","0","Micro","MicroFill"},
	{"%(def={\"TrivDef\",\"TrivDef\",\"TrivDef\",".. -- MicIncIns.ary SetTagIns.idx SetTagIns.val
	"\"GiveDef\",\"GiveDef\",".. -- WholeFrm.idx WholeFrm.siz
	"\"TrivDef\",\"TrivDef\",\"TrivDef\",".. -- MicroFrm.idx MicroFrm.siz MicroFrm.base
	"\"TrivDef\"};".. -- IdxDeeIns.idx
	"arg={0,0,castResrc(\"PierceRes\"),0,1,0,6,castMicro(\"MicroFill\"),castMicro(\"MicroFill\")};"..
	"count = 0; return \"Memory\")","Matrixz","Int","1","Int","1"},
	{"Memory","Getintz","Int","%(return rng(0,#arg-1))","Default","%(return fnc(def))"},
	{"Memory","Getintz","Int","%(return rng(0,#arg-1))","Int","%(return fnc(arg))"},
	-- Getintz: do MicroFill IncIns on a RelateRes; then do GetUse on the same RelateRes
}
ResrcIns = {
	-- n==0: departures from OldDerIns,Resrcs,Memorys,Micros,ResizeLoc,SizeFrm,Qualitys,Reuses
	-- n>0: departures from n-1
	{"Resrc","SwapRes","Int","0","Resrc","SwapRes"},
	 {"Resrc","SwapRes","Int","0","Memory","Memorys"},
	 {"Resrc","SwapRes","Int","0","Micro","Micros"},
	 {"Resrc","SwapRes","Int","0","Reloc","ResizeLoc"},
	 {"Resrc","SwapRes","Int","0","Format","FalseFrm"},
	 {"Resrc","SwapRes","Int","0","Quality","Qualitys"},
	 {"Resrc","SwapRes","Int","0","Reuse","Reuses"},
	{"Resrc","PipeRes","Int","0","Instr","IdxDerIns"},
	 {"Resrc","PipeRes","Int","0","Resrc","PipeRes"},
	 {"Resrc","PipeRes","Int","0","Format","PipeFrm"},
	 {"Resrc","PipeRes","Int","0","Default","GiveDef"},
	 {"Resrc","PipeRes","Int","0","Int","0"}, -- IdxDerIns
	 {"Resrc","PipeRes","Int","1","Default","BackDef"},
	 {"Resrc","PipeRes","Int","1","Int","0"}, -- Micro
	{"Resrc","ChainRes","Int","0","Resrc","ChainRes"},
	 {"Resrc","ChainRes","Int","0","Format","TrueFrm"},
}
ResrcAlt = {
	{"Resrc","SwapRes","Int","0","Instr","OldDerIns"},
	 {"Resrc","SwapRes","Int","0","Resrc","SwapRes"},
	 {"Resrc","SwapRes","Int","0","Memory","Memorys"},
	 {"Resrc","SwapRes","Int","0","Micro","Micros"},
	 {"Resrc","SwapRes","Int","0","Reloc","ResizeLoc"},
	 {"Resrc","SwapRes","Int","0","Format","FalseFrm"},
	 {"Resrc","SwapRes","Int","0","Quality","Qualitys"},
	 {"Resrc","SwapRes","Int","0","Reuse","Reuses"},
	 {"Resrc","SwapRes","Int","0","Default","TrivDef"},
	 {"Resrc","SwapRes","Int","0","Int","0"},
}
MicroIns = {
	-- n==0: departures from NewDerIns,Resrcs,Memorys,Micros,ResizeLoc,SizeFrm,Qualitys,Reuses
	-- n>0: departures from n-1
	{"%(mic = {\"MicroTest\"}\
	dee = {\"SwapRes\",\"ChainRes\",\"UniformRes\",\"MatrixRes\",\"ImageRes\",\"IndexRes\",\"BringupRes\"}\
	mib = {\"MicroDebug\"}\
	deb = {\"UniformRes\",\"MatrixRes\",\"ImageRes\",\"IndexRes\",\"BringupRes\"}\
	\
	def = {\"TrivDef\",\"TrivDef\",--[[TagIns]]\
	\"GiveDef\",\"GiveDef\",\"BackDef\",--[[MicroFrm BothReq:idx/siz MicroExt:base]]\
	\"BackDef\",--[[IdxDeeIns PipeRes:idx]]\
	\"BackDef\"--[[IdxDeeIns PipeRes:idx]]}\
	dv0 = {\"0\"}\
	dv1 = {\"0\",\"1\",\"1\",\"1\",\"1\"}\
	\
	deg = {\"TrivDef\",\"TrivDef\",--[[TagIns]]\
	\"GiveDef\",\"GiveDef\"--[[ExtentFrm SizeReq ExtentExt:base/size]],\
	\"GiveDef\",\"GiveDef\",\"BackDef\"--[[MicroFrm BothReq:idx/siz MicroExt:base]],\
	\"BackDef\"--[[IdxDeeIns PipeRes:idx]]}\
	dw0 = {\"0\"}\
	dw1 = {\"0\",\"1\",\"2\",\"3\",\"1\",\"1\"}\
	\
	function fnc (lst) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(v) else return v end end end\
	function gnc (lst,oth) for i,v in ipairs(lst) do for j,w in ipairs(oth) do if i ~= #lst or j~= #oth then coroutine.yield(v) else return v end end end end\
	function hnc (lst,num) for i,v in ipairs(lst) do if i ~= #lst then coroutine.yield(i+num-1) else return i+num-1 end end end\
	\
	return \"Micro\")","%(return fnc(mic))","Int","0","Instr","SetTagIns"},
		{"Micro","%(return fnc(mic))","Int","0","Resrc","DrawRes"},
		{"Micro","%(return fnc(mic))","Int","0","Quality","RsizQua"},
	{"Micro","%(return fnc(mic))","Int","1","Instr","NewDerIns"},
		{"Micro","%(return fnc(mic))","Int","1","Resrc","ChainRes"},
		{"Micro","%(return fnc(mic))","Int","1","Memory","Memorys"},
		{"Micro","%(return fnc(mic))","Int","1","Micro","Micros"},
		{"Micro","%(return fnc(mic))","Int","1","Reloc","BeforeLoc"},
		{"Micro","%(return fnc(mic))","Int","1","Format","NullFrm"},
		{"Micro","%(return fnc(mic))","Int","1","Quality","Qualitys"},
		{"Micro","%(return fnc(mic))","Int","1","Reuse","Reuses"},
	{"Micro","%(return fnc(mic))","Int","2","Instr","RdlDeeIns"},
		{"Micro","%(return fnc(mic))","Int","2","Resrc","SwapRes"},
	{"Micro","%(return fnc(mic))","Int","3","Instr","NewDerIns"},
		{"Micro","%(return fnc(mic))","Int","3","Resrc","DrawRes"},
		{"Micro","%(return fnc(mic))","Int","3","Reloc","MiddleLoc"},
		{"Micro","%(return fnc(mic))","Int","3","Format","MicroFrm"},
	{"Micro","%(return gnc(mic,dee))","Int","4","Instr","RdlDeeIns"},
		{"Micro","%(return gnc(mic,dee))","Int","%(return hnc(dee,4))","Resrc","%(return fnc(dee))"},
	{"Micro","%(return fnc(mic))","Int","%(return 4+#dee)","Instr","IdxDeeIns"},
		{"Micro","%(return fnc(mic))","Int","%(return 4+#dee)","Resrc","PipeRes"},
	{"Micro","%(return fnc(mic))","Int","%(return 5+#dee)","Instr","NewDerIns"},
		{"Micro","%(return fnc(mic))","Int","%(return 5+#dee)","Resrc","ChainRes"},
		{"Micro","%(return fnc(mic))","Int","%(return 5+#dee)","Reloc","AfterLoc"},
		{"Micro","%(return fnc(mic))","Int","%(return 5+#dee)","Format","NullFrm"},
	{"Micro","%(return fnc(mic))","Int","%(return 6+#dee)","Instr","RdlDeeIns"},
		{"Micro","%(return fnc(mic))","Int","%(return 6+#dee)","Resrc","SwapRes"},
	{"Micro","%(return fnc(mic))","Int","%(return 7+#dee)","Instr","IdxDeeIns"},
		{"Micro","%(return fnc(mic))","Int","%(return 7+#dee)","Resrc","PipeRes"},
	{"Micro","%(return gnc(mic,def))","Int","%(return hnc(def,0))","Default","%(return fnc(def))"},
	{"Micro","%(return gnc(mic,dv0))","Int","%(return hnc(dv0,0))","Int","%(return fnc(dv0))"},
	{"Micro","%(return fnc(mic))","Int","1","Int","%(return fnc(mic))"},
	{"Micro","%(return gnc(mic,dv1))","Int","%(return hnc(dv1,2))","Int","%(return fnc(dv1))"},

	{"Micro","%(return fnc(mib))","Int","0","Instr","SetTagIns"},
		{"Micro","%(return fnc(mib))","Int","0","Resrc","DrawRes"},
		{"Micro","%(return fnc(mib))","Int","0","Quality","RsizQua"},
	{"Micro","%(return fnc(mib))","Int","1","Instr","OldDerIns"},
		{"Micro","%(return fnc(mib))","Int","1","Resrc","PierceRes"},
		{"Micro","%(return fnc(mib))","Int","1","Reloc","ResizeLoc"},
		{"Micro","%(return fnc(mib))","Int","1","Reuse","SetUse"}, -- FdbUse should work too
		{"Micro","%(return fnc(mib))","Int","1","Format","ExtentFrm"},
	{"Micro","%(return fnc(mib))","Int","2","Instr","NewDerIns"},
		{"Micro","%(return fnc(mib))","Int","2","Resrc","DrawRes"},
		{"Micro","%(return fnc(mib))","Int","2","Reloc","MiddleLoc"},
		{"Micro","%(return fnc(mib))","Int","2","Format","MicroFrm"},
	{"Micro","%(return fnc(mib))","Int","3","Instr","WrlDeeIns"},
		{"Micro","%(return fnc(mib))","Int","3","Resrc","PierceRes"},
	{"Micro","%(return fnc(mib))","Int","4","Instr","RdlDeeIns"},
		{"Micro","%(return gnc(mib,deb))","Int","%(return hnc(deb,4))","Resrc","%(return fnc(deb))"},
	{"Micro","%(return fnc(mib))","Int","%(return 4+#deb)","Instr","IdxDeeIns"},
		{"Micro","%(return fnc(mib))","Int","%(return 4+#deb)","Resrc","PipeRes"},
	{"Micro","%(return gnc(mib,deg))","Int","%(return hnc(deg,0))","Default","%(return fnc(deg))"},
	{"Micro","%(return gnc(mib,dw0))","Int","%(return hnc(dw0,0))","Int","%(return fnc(dw0))"},
	{"Micro","%(return fnc(mib))","Int","1","Int","%(return fnc(mib))"},
	{"Micro","%(return gnc(mib,dw1))","Int","%(return hnc(dw1,2))","Int","%(return fnc(dw1))"},

	{"Micro","MicroFill","Int","0","Instr","SetTagIns"},
		{"Micro","MicroFill","Int","0","Resrc","DrawRes"},
		{"Micro","MicroFill","Int","0","Quality","RsizQua"},
	{"Micro","MicroFill","Int","1","Instr","OldDerIns"},
		{"Micro","MicroFill","Int","1","Resrc","RelateRes"},
		{"Micro","MicroFill","Int","1","Reloc","ResizeLoc"},
		{"Micro","MicroFill","Int","1","Reuse","FdbUse"},
		{"Micro","MicroFill","Int","1","Format","ExtentFrm"},
	{"Micro","MicroFill","Int","2","Instr","OldDerIns"},
		{"Micro","MicroFill","Int","2","Resrc","RelateRes"},
		{"Micro","MicroFill","Int","2","Reloc","ReformLoc"},
		{"Micro","MicroFill","Int","2","Format","PierceFrm"},
	-- {"Micro","MicroFill","Int","3","Instr","OldDerIns"},
	-- 	{"Micro","MicroFill","Int","3","Resrc","RelateRes"},
	-- 	{"Micro","MicroFill","Int","3","Reloc","BeforeLoc"},
	-- 	{"Micro","MicroFill","Int","3","Format","PokeFrm"},
	{"Micro","MicroFill","Int","3","Instr","NewDerIns"},
		{"Micro","MicroFill","Int","3","Resrc","DrawRes"},
		{"Micro","MicroFill","Int","3","Reloc","MiddleLoc"},
		{"Micro","MicroFill","Int","3","Format","MicroFrm"},
	{"Micro","MicroFill","Int","4","Instr","IdxDeeIns"},
		{"Micro","MicroFill","Int","4","Resrc","PipeRes"},
	{"Micro","MicroFill","Int","5","Instr","RdlDeeIns"},
		{"Micro","MicroFill","Int","5","Resrc","UniformRes"},
	{"Micro","MicroFill","Int","6","Instr","WrlDeeIns"},
		{"Micro","MicroFill","Int","6","Resrc","RelateRes"},
	-- {"Micro","MicroFill","Int","8","Instr","OldDerIns"},
	-- 	{"Micro","MicroFill","Int","8","Resrc","RelateRes"},
	-- 	{"Micro","MicroFill","Int","8","Reloc","AfterLoc"},
	-- 	{"Micro","MicroFill","Int","8","Format","DestFrm"},
	{"Micro","MicroFill","Int","0","Default","TrivDef"},
		{"Micro","MicroFill","Int","0","Int","0"}, -- SetTagIns.idx
	{"Micro","MicroFill","Int","1","Default","TrivDef"},
		{"Micro","MicroFill","Int","1","Int","%(return castMicro(\"MicroFill\"))"}, -- SetTagIns.val
	{"Micro","MicroFill","Int","2","Default","GiveDef"},
		{"Micro","MicroFill","Int","2","Int","0"},
	{"Micro","MicroFill","Int","3","Default","GiveDef"},
		{"Micro","MicroFill","Int","3","Int","1"},
	{"Micro","MicroFill","Int","4","Default","TrivDef"},
		{"Micro","MicroFill","Int","4","Int","0"}, -- MicroFrm.idx
	{"Micro","MicroFill","Int","5","Default","TrivDef"},
		{"Micro","MicroFill","Int","5","Int","6"}, -- MicroFrm.siz
	{"Micro","MicroFill","Int","6","Default","TrivDef"},
		{"Micro","MicroFill","Int","6","Int","%(return castMicro(\"MicroFill\"))"}, -- MicroFrm.base
	{"Micro","MicroFill","Int","7","Default","TrivDef"},
		{"Micro","MicroFill","Int","7","Int","%(return castMicro(\"MicroFill\"))"}, -- IdxDeeIns.idx
}
MicroAlt = {
	{"Micro","MicroTest","Int","0","Instr","NewDerIns"},
		{"Micro","MicroTest","Int","0","Resrc","ChainRes"},
		{"Micro","MicroTest","Int","0","Memory","Memorys"},
		{"Micro","MicroTest","Int","0","Micro","Micros"},
		{"Micro","MicroTest","Int","0","Reloc","BeforeLoc"},
		{"Micro","MicroTest","Int","0","Format","MicroFrm"},
		{"Micro","MicroTest","Int","0","Quality","Qualitys"},
		{"Micro","MicroTest","Int","0","Reuse","Reuses"},
		{"Micro","MicroTest","Int","0","Default","TrivDef"},
		{"Micro","MicroTest","Int","0","Int","0"},
}
-- i<Memorys centerPull(i)->mem==i
-- i>=Memorys&&i<Memorys+4 scratchpad as src or dest of Transfer
-- i>Memorys+4 Machine arrays as callable procedures
-- i==Machinez is main machine that waits for bit MachThd in RegisterWake
-- TODO in Builtin, have planeDebug use planeMatrix depending on commandline.
-- TODO in Regress, use Center pipe instead of planeTest.
-- TODO in Release, use mouse and roller instead of Center spoofs.
Bootstrap = {
	{"Int","%(count = 0; function idx() count = count + 1; return count end;"..
		"dount = 0; function jdx() dount = dount + 1; return dount end;"..
		"return count)","Str","!(index = #%(return count))Indexz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(bringup = #%(return count))Bringupz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(image = #%(return count))Imagez(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(getint = #%(return count))Getintz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(getold = #%(return count))Getoldz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(setint = #%(return count))Setintz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(setold = #%(return count))Setoldz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(uniform = #%(return count))Uniformz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(matrix = #%(return count))Matrixz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(triangle = #%(return count))Trianglez(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(numeric = #%(return count))Numericz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(vertex = #%(return count))Vertexz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(basis = #%(return count))Basisz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(draw = #%(return count))Drawz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(instr = #%(return count))Instrz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(string = #%(return count))Stringz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(machine = #%(return count))Machinez(siz:64idx:0slf:0"..
		"mch[%(return dount)]:Void(exp[0]:$(Non mask = #0 ; pass = #0 ; fail = #0 Op))"..
		"mch[%(return jdx())]:Nest(lvl:1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Woc RegisterWake @mask Op))"..
		-- "mch[%(return jdx())]:Void(exp[0]:$(Put StrGoodby Op , Imm TimOp Op , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0))"..
		-- "mch[%(return jdx())]:Void(exp[0]:$(Put StrHello Op , Imm TimOp Op , EndOp Op))"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non mask = Top RegisterWake Op ; tmp = #0 Op))"..
		"mch[%(return jdx())]:Nest(lvl:14)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non fns = @tmp ; tmp = @mask >> @fns Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(Cnd"..
		" @tmp != @fns , #0-#15"..
		" EO @tmp - #1 #%(return castMask(\"FnceMsk\")) Cmp , #1"..
		" EO @tmp - #1 #%(return castMask(\"SlctMsk\")) Cmp , #2"..
		" EO @tmp - #1 #%(return castMask(\"CnslMsk\")) Cmp , #3"..
		" EO @tmp - #1 #%(return castMask(\"TimeMsk\")) Cmp , #4"..
		" EO @tmp - #1 #%(return castMask(\"PassMsk\")) Cmp , #5"..
		" EO @tmp - #1 #%(return castMask(\"FailMsk\")) Cmp , #6"..
		" EO @tmp - #1 #%(return castMask(\"DropMsk\")) Cmp , #7"..
		" EO @tmp - #1 #%(return castMask(\"PollMsk\")) Cmp , #8"..
		" EO @tmp - #1 #%(return castMask(\"PrssMsk\")) Cmp , #9"..
		" EO @tmp - #1 #%(return castMask(\"SizeMsk\")) Cmp , #10"..
		" EO @tmp - #1 #%(return castMask(\"MoveMsk\")) Cmp , #11"..
		" EO @tmp - #1 #%(return castMask(\"ClckMsk\")) Cmp , #12"..
		" EO @tmp - #1 #%(return castMask(\"RollMsk\")) Cmp , #13"..
		" EO @tmp - #1 #%(return castMask(\"UnifMsk\")) Cmp , #14"..
		"Op))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		-- "mch[%(return jdx())]:Void(exp[0]:$(Put StrFnceMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrSlctMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrCnslMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non RegisterTime := #500 << #8 ; Put StrTimeMsk Op , Imm TimOp Op , EndOp Op Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non nask = ?RegisterPass ; smp = #0 ; pass = @pass + #1 Op))"..
		"mch[%(return jdx())]:Nest(lvl:2)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non gns = @smp ; smp = @nask >> @gns Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(Cnd @smp != @gns , #2 ; #0 , #1 Op))"..
		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Eval(res[0]:$(@smp - #1)fnc[0]:$(Cnd "..
		 "EO @_ . slf 0 #0 Cmp | EO Cst @_ . mem 0 #0 Op #%(return castMemory(\"Getoldz\")) Cmp | EO @_ . siz 0 #1 Cmp : "..
		  "Non Put StrPassMsk Op , Imm TimOp Op , Str pass:Op , Imm @pass Op , Str fail:Op , Imm @fail Op , Str sub:Op , Imm @smp - #1 Op , Str mem:Op , Imm @_ . mem 0 Op , Str num:Op , Imm @_ . old 0 Op , EndOp Op ; @_ Op "..
		 "EO @_ . slf 0 #0 Cmp | EO Cst @_ . mem 0 #0 Op #%(return castMemory(\"Getintz\")) Cmp | EO @_ . siz 0 #1 Cmp : "..
		  "Non Put StrPassMsk Op , Imm TimOp Op , Str pass:Op , Imm @pass Op , Str fail:Op , Imm @fail Op , Str sub:Op , Imm @smp - #1 Op , Str mem:Op , Imm @_ . mem 0 Op , Str num:Op , Imm @_ . uns 0 Op , EndOp Op ; @_ Op "..
		 "#0 : @_ Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..
		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Woc RegisterPass @nask Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non nask = ?RegisterFail ; smp = #0 ; fail = @fail + #1 Op))"..
		"mch[%(return jdx())]:Nest(lvl:2)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Non gns = @smp ; smp = @nask >> @gns Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(Cnd @smp != @gns , #2 ; #0 , #1 Op))"..
		"mch[%(return jdx())]:Nest(lvl:-1)"..
		-- "mch[%(return jdx())]:Void($(Put StrFailMsk Op , Imm @smp - #1 Op , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..
		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Woc RegisterFail @nask Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrDropMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrPollMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrPrssMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrSizeMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrMoveMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrClckMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Void(exp[0]:$(Put StrRollMskOp , EndOp Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..

		"mch[%(return jdx())]:Nest(lvl:-1)"..
		"mch[%(return jdx())]:Eval(res[0]:$(@uniform)fnc[0]:$(Non Put StrUnifMsk Op , Imm TimOp Op , Str Op , Imm @_ Op , EndOp Op ; @_ Op))"..
		"mch[%(return jdx())]:Jump(exp[0]:$(#0-#1))"..
	")"},
	{"Int","%(return idx())","Str","!(express = #%(return count) count = #5)"..
		"Expressz(siz:1idx:0slf:0exp[0]:$(Non "..
		"RegisterTime := #750 << #8 "..
		"count = @count + #1 "..
		"Put Imm TimOp Op EndOp Op "..
		"Op))"},
	{"Int","%(return idx())","Str","!(kernel = #%(return count))Kernelz(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","!(configure = #%(return count))Configurez(siz:0idx:0slf:0)"},
	{"Int","%(return idx())","Str","Indexz(siz:0idx:0slf:0)"}, -- scratch
	{"Int","%(return idx())","Str","Indexz(siz:0idx:0slf:0)"}, -- scratch
	{"Int","%(return idx())","Str","Indexz(siz:0idx:0slf:0)"}, -- scratch
	{"Int","%(return idx())","Str","Indexz(siz:0idx:0slf:0)"}, -- scratch
	{"Int","%(return idx())","Str","!(pass = #0 fail = #0 wake = #0)"..
		"Force(num:1cfg[0]:RegisterPlanval[0]:CndOp(siz:5"..
		"cnd[0]:CmpOp(cmp:EOCmpopc[0]:RetOp(RegisterShow)opc[1]:IntOp(0))".. -- (RegisterShow != 0 ? 1 : 0)
		"cnd[1]:CmpOp(cmp:EOCmpopc[0]:AddOp("..
			"opa[0]:CmpOp(cmp:ECCmpopc[0]:BitOp(bit:AndBitopb[0]:RetOp(RegisterShow)opb[1]:IntOp(1))opc[1]:IntOp(0))"..
			"opa[1]:CmpOp(cmp:EOCmpopc[0]:BitOp(bit:AndBitopb[0]:RetOp(RegisterShow)opb[1]:IntOp(30))opc[1]:IntOp(0))"..
			")opc[1]:IntOp(2))".. -- ((((RegisterShow & 1) == 0) + ((RegisterShow & 30) != 0)) != 2 ? 1 : 0)
		"cnd[2]:CmpOp(cmp:EOCmpopc[0]:AddOp("..
			"opa[0]:CmpOp(cmp:EOCmpopc[0]:BitOp(bit:AndBitopb[0]:RetOp(RegisterShow)opb[1]:IntOp(1))opc[1]:IntOp(0))"..
			"opa[1]:CmpOp(cmp:EOCmpopc[0]:BitOp(bit:AndBitopb[0]:RetOp(RegisterShow)opb[1]:IntOp(30))opc[1]:IntOp(0))"..
			")opc[1]:IntOp(2))".. -- ((((RegisterShow & 1) != 0) + ((RegisterShow & 30) != 0)) != 2 ? 1 : 0)
		"cnd[3]:CmpOp(cmp:EOCmpopc[0]:RetOp(RegisterShow)opc[1]:IntOp(1))".. -- (RegisterShow != 1 ? 1 : 0)
		"cnd[4]:IntOp(0)"..
		"lst[0]:IntOp(%(return castPlan(\"Bringup\")))"..
		"lst[1]:IntOp(%(return castPlan(\"Builtin\")))"..
		"lst[2]:IntOp(%(return castPlan(\"Regress\")))"..
		"lst[3]:IntOp(%(return castPlan(\"Release\")))"..
		"lst[4]:IntOp(-1)))"},
}
Execname = {
	{"Program","Filez","Str","./file"},
	{"Program","Holez","Str","./hole"},
	{"Program","Linez","Str","./line"},
	{"Program","Planez","Str","./plane"},
	{"Program","Spacez","Str","./space"},
	{"Program","Sidez","Str","./side"},
	{"Program","Framez","Str","./frame"},
	{"Program","Sharez","Str","./share"},
}
--HERE Structs
Persist = { -- for file hole side
	{"act","Goal",{},{}},
	{"idx","Int",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true
	}},{}}, -- identifier for file
	{"loc","New",{["act"]={
		["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true,
		["HubCfg"]=true
	}},{}}, -- location in file
	{"pid","New",{["act"]={
		["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,["ThdThd"]=true
	}},{}}, -- process id for fifo
	{"slf","Int",{["act"]={
		["HubCfg"]=true
	}},{}}, -- whether process id is self
	{"str","Str",{["act"]={
		["NewHub"]=true,["CfgHub"]=true,["AppHub"]=true,["ThdHub"]=true,
		["HubThd"]=true,["AppThd"]=true,
		["HubCfg"]=true,
		["ThdErr"]=true,["HubErr"]=true
	}},{}}, -- file or field
}
Term0 = {
	{"cff","Num",{},{}},
}
Term1 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{1}},
}
Term2 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{2}},
}
Term3 = {
	{"cff","Num",{},{}},
	{"vry","Int",{},{3}},
}
Nomial = {
	{"num0","Int",{},{}},
	{"trm0","Term0",{},"num0"},
	{"num1","Int",{},{}},
	{"trm1","Term1",{},"num1"},
	{"num2","Int",{},{}},
	{"trm2","Term2",{},"num2"},
	{"num3","Int",{},{}},
	{"trm3","Term3",{},"num3"},
}
Ratio = {
	{"num","Nomial",{},{}},
	{"den","Nomial",{},{}},
}
Event = { -- for line process
	{"tag","Level",{},{}},
	{"idx","Int",{},{}},
	{"oth","Int",{},{}},
	{"key","Num",{},{}},
	{"val","Num",{},{}},
	{"upd","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"dly","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"sch","Ratio",{["tag"]={["Stock"]=true}},{}},
	{"flw","Flow",{["tag"]={["Link"]=true}},{}},
	{"siz","Int",{["tag"]={["Wave"]=true}},{}},
	{"buf","Num",{["tag"]={["Wave"]=true}},"siz"},
	{"num","Int",{["tag"]={["Timer"]=true}},{}},
	{"tot","Int",{["tag"]={["Timer"]=true}},{}},
	{"ids","Int",{["tag"]={["Timer"]=true}},"num"},
	{"req","Int",{["tag"]={["Timer"]=true}},"num"},
	{"rsp","Num",{["tag"]={["Timer"]=true}},"tot"},
	{"wrp","Num",{["tag"]={["Audio"]=true}},{}},
	{"gap","Int",{["tag"]={["Audio"]=true}},{}},
	{"cdt","Int",{["tag"]={["Audio"]=true}},{}},
	{"len","Int",{["tag"]={["Audio"]=true}},{}},
	{"enb","Int",{["tag"]={["Audio"]=true}},{}},
}
Irrex = { -- permutation of permutations
	-- prm of zero is always valid
	-- advance top level prm first, otherwise
	-- reset top level and advence next level down
	{"str","Str",{},{}}, -- stateful evaluation
	{"prm","Int",{},{}}, -- stateful evaluation
	{"msk","Int",{},{}}, -- stateful evaluation
	{"ord","Order",{},{}}, -- type of comparison
	{"siz","Int",{},{}}, -- zero for ChrOrd
	{"sub","Irrex",{},"siz"},
}
Express = {
	{"opr","Operate",{},""},
	{"opa","Express",{["opr"]={["AddOp"]=true,["SubOp"]=true,["MulOp"]=true,["DivOp"]=true,["RemOp"]=true,["CstOp"]=true}},2},
	{"bit","Bitwise",{["opr"]={["BitOp"]=true}},{}},
	{"opb","Express",{["opr"]={["BitOp"]=true}},2},
	{"cmp","Compare",{["opr"]={["CmpOp"]=true}},{}},
	{"opc","Express",{["opr"]={["CmpOp"]=true}},2},
	{"siz","Int",{["opr"]={["CndOp"]=true}},{}},
	{"cnd","Express",{["opr"]={["CndOp"]=true}},"siz"},
	{"lst","Express",{["opr"]={["CndOp"]=true}},"siz"},
	{"num","Int",{["opr"]={["NonOp"]=true,["PutOp"]=true}},{}},
	{"non","Express",{["opr"]={["NonOp"]=true,["PutOp"]=true}},"num"},
	{"cfg","Configure",{["opr"]={["RetOp"]=true,["TopOp"]=true}},{}},
	{"cgs","Configure",{["opr"]={["SetOp"]=true,["WosOp"]=true,["WocOp"]=true,["RawOp"]=true}},{}},
	{"set","Express",{["opr"]={["SetOp"]=true,["WosOp"]=true,["WocOp"]=true,["RawOp"]=true}},1},
	{"key","Str",{["opr"]={["ValOp"]=true,["RexOp"]=true,["IrxOp"]=true,["StrOp"]=true}},{}},
	{"lhs","Str",{["opr"]={["SavOp"]=true}},{}},
	{"rhs","Express",{["opr"]={["SavOp"]=true}},1},
	{"put","Express",{["opr"]={["SrcOp"]=true,["ImmOp"]=true}},1},
	{"fld","Express",{["opr"]={["FldOp"]=true}},2},
	{"fid","Str",{["opr"]={["FldOp"]=true}},{}},
	{"fub","Int",{["opr"]={["FldOp"]=true}},{}},
	{"ext","Express",{["opr"]={["ExtOp"]=true}},1},
	{"eid","Str",{["opr"]={["ExtOp"]=true}},{}},
	{"eub","Int",{["opr"]={["ExtOp"]=true}},{}},
	{"val","Int",{["opr"]={["IntOp"]=true}},{}},
}
Machine = {
	{"xfr","Transfer",{},""},
	{"siz","Int",{["xfr"]={["Stage"]=true,["Tsage"]=true}},{}},
	{"sav","Configure",{["xfr"]={["Stage"]=true,["Tsage"]=true}},"siz"},
	{"idx","Express",{["xfr"]={["Stage"]=true,["Tsage"]=true}},1},
	{"num","Int",{["xfr"]={["Force"]=true}},{}},
	{"cfg","Configure",{["xfr"]={["Force"]=true}},"num"},
	{"val","Express",{["xfr"]={["Force"]=true}},"num"},
	{"res","Express",{["xfr"]={["Eval"]=true}},1},
	{"fnc","Express",{["xfr"]={["Eval"]=true}},1},
	{"sig","Int",{["xfr"]={["Argv"]=true,
		["Comp"]=true,["Form"]=true,["Send"]=true,["Self"]=true,["Glob"]=true,
		["Bopy"]=true,["Copy"]=true,["Dopy"]=true,["Popy"]=true,["Qopy"]=true}},{}},
	{"arg","Express",{["xfr"]={["Argv"]=true,
		["Comp"]=true,["Form"]=true,["Send"]=true,["Self"]=true,["Glob"]=true,
		["Bopy"]=true,["Copy"]=true,["Dopy"]=true,["Popy"]=true,["Qopy"]=true}},"sig"},
	{"exp","Express",{["xfr"]={["Jump"]=true,["Goto"]=true,["Void"]=true}},1},
	{"lvl","Int",{["xfr"]={["Nest"]=true}},{}},
}
Uniform = {
	{"all","Int32",{},{}}, -- which subject to use
	{"one","Int32",{},{}}, -- which element to use
	{"idx","Int32",{},{}}, -- which plane to manipulate
	{"use","Int32",{},{}}, -- which basis to use

	{"tri","Int32",{},{}}, -- base of triangles
	{"num","Int32",{},{}}, -- base of numerics
	{"vtx","Int32",{},{}}, -- base of vertices
	{"mat","Int32",{},{}}, -- base of matrices

	{"bas","Int32",{},{}}, -- base of basises
	{"mod","Int32",{},{}}, -- fetch/storage vertices/planes
	{"wid","Int32",{},{}}, -- width of image
	{"hei","Int32",{},{}}, -- height of image
}
Triangle = {
	{"vtx","Int32",{},{4}}, -- points of triangle
	{"num","Int32",{},{}}, -- plane of points
	{"pol","Int32",{},{}}, -- polytope triangle is in
	{"tex","Int32",{},{}}, -- texture selector
	{"rot","Int32",{},{}}, -- texture rotation
}
Numeric = {
	{"vec","Old",{},{4}}, -- distances above basis
	{"bas","Int32",{},{}}, -- basis selector
	{"pad","Int32",{},{3}},
}
Vertex = {
	{"vec","Old",{},{4}}, -- intersection of planes
	{"ord","Old",{},{4}}, -- coordinate or color
	{"ref","Int32",{},{4}}, -- backreference to planes
}
Vector = {
	{"vec","Old",{},{4}},
}
Matrix = {
	{"mat","Old",{},{16}},
}
Kernel = {
	{"saved","Matrix",{},{}},
	{"local","Matrix",{},{}},
	{"sent","Matrix",{},{}},
	{"global","Matrix",{},{}},
}
Basis = {
	{"mat","Vector",{},{9}},
}
Image = {
	{"dat","Dat",{},{}},
	{"wid","Int",{},{}},
	{"hei","Int",{},{}},
	{"cha","Int",{},{}},
}
Decorate = {
	{"dec","Decor",{},{}}, -- operation
	{"nxt","Int",{},{}}, -- next graph node unless compare fail
	{"dim","Int",{},{}},
	{"src","Swizzle",{},"dim"}, -- which input or buffer array
	{"idx","Int",{},"dim"}, -- which input or buffer element
	{"acc","Swizzle",{},{}}, -- which accumulator
}
Const = {
	{"tag","Constant",{},{}},
	{"mic","Micro",{["tag"]={["MicroCon"]=true}},{}},
	{"mem","Memory",{["tag"]={["MemoryCon"]=true}},{}},
	{"res","Resrc",{["tag"]={["ResrcCon"]=true}},{}},
}
Draw = {
	{"con","Const",{},{}},
	{"ptr","Dat",{},{}},
	{"siz","Int",{},{}},
	{"sze","Int",{},{}},
	{"arg","Int",{},"siz"},
	{"val","Int",{},"sze"},
}
Requ = {
	{"tag","Request",{},{}},
	{"ptr","Dat",{},{}},
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
	{"ext","Extent",{},{}},
	{"base","Int",{},{}},
	{"size","Int",{},{}},
	{"loc","Reloc",{},{}},
}
Inst = {
	{"ins","Instr",{},""},
	{"req","Requ",{},{}}, -- only used by DerIns TODO change to pointer
	{"res","Resrc",{},{}}, -- used by DerIns DeeIns IncIns TagIns
	{"mem","Memory",{},{}}, -- only used by IncIns
	{"mic","Micro",{},{}}, -- only used by IncIns
	{"idx","Int",{},{}}, -- used by DerIns DeeIns TagIns
	{"key","Quality",{},{}}, -- used by DerIns DeeIns TagIns
	{"val","Int",{},{}}, -- used by DerIns DeeIns TagIns
}
Center = {
	{"mem","Memory",{},""},
	{"siz","Int",{},{}},
	{"idx","Int",{},{}},
	{"slf","Int",{},{}},
	{"ind","Int32",{["mem"]={["Indexz"]=true}},"siz"},
	{"ver","Vertex",{["mem"]={["Bringupz"]=true}},"siz"},
	{"img","Image",{["mem"]={["Imagez"]=true}},"siz"},
	{"uns","Int32",{["mem"]={["Getintz"]=true,["Setintz"]=true}},"siz"},
	{"old","Old",{["mem"]={["Getoldz"]=true,["Setoldz"]=true}},"siz"},
	{"uni","Uniform",{["mem"]={["Uniformz"]=true}},"siz"},
	{"mat","Matrix",{["mem"]={["Matrixz"]=true}},"siz"},
	{"tri","Triangle",{["mem"]={["Trianglez"]=true}},"siz"},
	{"num","Numeric",{["mem"]={["Numericz"]=true}},"siz"},
	{"vtx","Vertex",{["mem"]={["Vertexz"]=true}},"siz"},
	{"bas","Basis",{["mem"]={["Basisz"]=true}},"siz"},
	{"drw","Draw",{["mem"]={["Drawz"]=true}},"siz"},
	{"ins","Inst",{["mem"]={["Instrz"]=true}},"siz"},
	{"str","Str",{["mem"]={["Stringz"]=true}},"siz"},
	{"mch","Machine",{["mem"]={["Machinez"]=true}},"siz"},
	{"exp","Express",{["mem"]={["Expressz"]=true}},"siz"},
	{"ker","Kernel",{["mem"]={["Kernelz"]=true}},"siz"},
	{"cfg","Configure",{["mem"]={["Configurez"]=true}},"siz"},
	{"val","Int",{["mem"]={["Configurez"]=true}},"siz"},
}
Listed = {
	{"siz","Int",{},{}},
	{"idx","Int",{},"siz"},
}
Nested = {
	{"siz","Int",{},{}},
	{"lst","Listed",{},"siz"},
}
Scalar = {
	{"num","Old",{},3},
}
Change = {
	{"cfg","Emerg",{},{}},
	{"vld","Valid",{},{}},
	{"idx","Int",{},{}},
	{"siz","Int",{},{}},
	{"vec","Scalar",{["vld"]={["Toread"]=true,["Towrite"]=true},["cfg"]={["Planes"]=true}},"siz"},
	{"nst","Nested",{["vld"]={["Toread"]=true,["Towrite"]=true},["cfg"]={["Halfs"]=true,}},"siz"},
	{"lst","Listed",{["vld"]={["Toread"]=true,["Towrite"]=true},["cfg"]={["Coins"]=true}},"siz"},
	{"num","Int",{["vld"]={["Toread"]=true,["Towrite"]=true},["cfg"]={["Subsets"]=true}},"siz"},
	{"pnt","Scalar",{["vld"]={["Toread"]=true},["cfg"]={["Points"]=true}},"siz"},
	{"fct","Listed",{["vld"]={["Toread"]=true},["cfg"]={["Facets"]=true}},"siz"},
}
Argument = {
	{"typ","Program",{},""},
	{"inp","Int",{},{}},
	{"out","Int",{},{}},
	{"idx","Int",{},{}},
	{"str","Str",{["typ"]={["Holez"]=true}},{}},
}
Valve = {
	{"tag","Stream",{},""},
	{"siz","Int",{["tag"]={["Fanout"]=true}},{}},
	{"dst","Str",{["tag"]={["Fanout"]=true}},"siz"},
	{"typ","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true,["Execute"]=true}},{}},
	{"str","Str",{["tag"]={["Fanout"]=true,["Buffer"]=true}},{}},
	{"url","Str",{["tag"]={["Execute"]=true}},{}},
	{"arg","Argument",{["tag"]={["Execute"]=true}},1},
	{"exp","Express",{["tag"]={["Combine"]=true}},1},
	{"num","Int",{["tag"]={["Combine"]=true}},{}},
	{"dep","Str",{["tag"]={["Combine"]=true}},"num"},
}
--HERE
-- below for depend.lua
Wrap = {
}
Subtype = {
}
Field = {
}
Type = {
}
-- above for depend.lua
Enums,Enumz = listHere("Enums","type.gen")
Constants,Constantz = listHere("Constants","type.gen")
Structs,Structz = listHere("Structs","type.gen")
function showTypeC(args)
	local result = ""
	result = result.."#include \"face.h\"\n"
	result = result.."#include \"type.h\"\n"
	result = result.."#include <stdlib.h>\n"
	result = result.."#include <string.h>\n"
	result = result.."#include <stdio.h>\n"
	result = result.."#include <unistd.h>\n"
	result = result.."#include <sys/errno.h>\n"
	result = result..showCallC(args).."\n"
	if (not args or args["execWrap"]) then
	result = result.."int execWrap(struct Argument *arg, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."int idx = openFork();\n"
	result = result..showIndent(1).."if (idx < 0) return -1;\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) {\n"
	result = result..showIndent(2).."char *str = 0;\n"
	result = result..showIndent(2).."arg->inp=openRdfd(idx); arg->out=openWrfd(idx);\n"
	result = result..showIndent(2).."showArgument(arg,&str);\n"
	result = result..showIndent(2).."openExec(exec,str); fprintf(stderr,\"%s: cannot execute file: %s\\n\",fork,exec); ERROR();}\n"
	result = result..showIndent(1).."return idx;}\n" end
	if (not args or args["typeWrap"]) then
	result = result.."int typeWrap(enum Program typ, const char *fork, const char *exec) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."arg.typ = typ;\n"
	result = result..showIndent(1).."return execWrap(&arg,fork,exec);}\n" end
	if (not args or args["initWrap"]) then
	result = result.."int initWrap(struct Argument *arg, const char *str) {\n"
	result = result..showIndent(1).."int len = 0;\n"
	result = result..showIndent(1).."if (!hideArgument(arg,str,&len)) return -1;\n"
	result = result..showIndent(1).."arg->idx = rdwrInit(arg->inp,arg->out);\n"
	result = result..showIndent(1).."return 0;}\n" end
	if (not args or args["identWrap"]) then
	result = result.."int identWrap(enum Program typ, const char *str) {\n"
	result = result..showIndent(1).."struct Argument arg = {0};\n"
	result = result..showIndent(1).."if (initWrap(&arg,str) < 0 || arg.typ != typ) return -1;\n"
	result = result..showIndent(1).."return arg.idx;}" end
	return result
end
function showTypeH()
	local result = ""
	result = result.."#include \"proto.h\"\n"
	result = result..showCallH().."\n"
	result = result.."int execWrap(struct Argument *arg, const char *fork, const char *exec);\n"
	result = result.."int typeWrap(enum Program typ, const char *fork, const char *exec);\n"
	result = result.."int initWrap(struct Argument *arg, const char *str);"
	result = result.."int identWrap(enum Program typ, const char *str);\n"
	return result
end
function showTypeHs(args)
	local result = ""
	result = result.."module Type where\n"
	result = result.."--\n"
	result = result.."import Face\n"
	result = result.."import System.Environment\n"
	result = result.."import System.IO\n"
	result = result.."import Data.IORef\n"
	result = result.."import Data.Int\n"
	result = result.."import Foreign.C.Types\n"
	result = result.."--\n"
	result = result.."type Dat = [CChar]\n"
	result = result..showCallHs(arg).."\n"
	-- if (not args or args["Wrap"]) then
	result = result.."execWrap :: Argument -> String -> String -> IO (Maybe Int)\n"
	result = result.."execWrap (Argument (ArgumentA1 typ _ _ idx) arg) fork exec = do\n"
	result = result..showIndent(1).."idx <- openFork\n"
	result = result..showIndent(1).."if idx < 0 then return Nothing else do\n"
	result = result..showIndent(2).."vld <- openCheck idx\n"
	result = result..showIndent(2).."if vld < 0 then return (Just idx) else do\n"
	result = result..showIndent(3).."inp <- openRdfd idx\n"
	result = result..showIndent(3).."out <- openWrfd idx\n"
	result = result..showIndent(3).."ptr <- newIORef \"\"\n"
	result = result..showIndent(3).."showArgument (Argument (ArgumentA1 typ inp out idx) arg) ptr\n"
	result = result..showIndent(3).."str <- readIORef ptr\n"
	result = result..showIndent(3).."openExec exec str\n"
	result = result..showIndent(3).."hPutStrLn stderr (fork ++ \": cannot execute file: \" ++ exec)\n"
	result = result..showIndent(3).."callExit (negate 1)\n"
	result = result..showIndent(3).."return Nothing\n"
	result = result.."typeWrap :: Program -> String -> String -> IO (Maybe Int)\n"
	result = result.."typeWrap typ fork exec = execWrap (Argument (ArgumentA1 typ 0 0 0) ArgumentA5Bs) fork exec\n"
	result = result.."initWrapF :: Maybe Argument -> IO (Maybe Argument)\n"
	result = result.."initWrapF Nothing = return Nothing\n"
	result = result.."initWrapF (Just (Argument (ArgumentA1 typ inp out _) arg)) = do\n"
	result = result..showIndent(1).."idx <- rdwrInit inp out\n"
	result = result..showIndent(1).."return (Just (Argument (ArgumentA1 typ inp out idx) arg))\n"
	result = result.."initWrap :: String -> IO (Maybe Argument)\n"
	result = result.."initWrap str = newIORef str >>= hideArgument >>= initWrapF\n"
	result = result.."identWrapF :: Program -> Maybe Argument -> IO (Maybe Int)\n"
	result = result.."identWrapF _ Nothing = return Nothing\n"
	result = result.."identWrapF cmp (Just (Argument (ArgumentA1 typ _ _ idx) _)) =\n"
	result = result..showIndent(1).."if cmp /= typ then\n"
	result = result..showIndent(1).."return Nothing else\n"
	result = result..showIndent(1).."return (Just idx)\n"
	result = result.."identWrap :: Program -> String -> IO (Maybe Int)\n"
	result = result.."identWrap typ str = initWrap str >>= identWrapF typ\n" -- end
	return result
end
function showTypeLua()
	local result = ""
	result = result.."require \"luax\"\n"
	result = result.."--\n"
	result = result..showCallLua().."\n"
	result = result.."function execWrap(arg,fork,exec)\n"
	result = result..showIndent(1).."idx = openFork()\n"
	result = result..showIndent(1).."if (idx < 0) then return -1 end\n"
	result = result..showIndent(1).."if (openCheck(idx) >= 0) then\n"
	result = result..showIndent(1).."arg[\"inp\"]=openRdfd(idx); arg[\"out\"]=openWrfd(idx); arg[\"idx\"]=-1\n"
	result = result..showIndent(1).."if (arg[\"typ\"] == nil) then arg[\"typ\"] = \"Programs\"end\n"
	result = result..showIndent(2).."str = showArgument(arg,\"\")\n"
	result = result..showIndent(2).."openExec(exec,str); io.stderr:write(fork..\": cannot execute file: \"..exec..\"\\n\"); os.exit(-1)\n"
	result = result..showIndent(1).."end\n"
	result = result..showIndent(1).."return idx\n"
	result = result.."end\n"
	result = result.."function typeWrap(typ,fork,exec)\n"
	result = result..showIndent(1).."arg[\"typ\"] = typ\n"
	result = result..showIndent(1).."return execWrap(arg,fork,exec)\n"
	result = result.."end\n"
	result = result.."function initWrap(str)\n"
	result = result..showIndent(1).."arg,len = hideArgument(str,0)\n"
	result = result..showIndent(1).."if (arg == nil) then return nil end\n"
	result = result..showIndent(1).."arg[\"idx\"] = rdwrInit(arg[\"inp\"],arg[\"out\"])\n"
	result = result..showIndent(1).."return arg\n"
	result = result.."end\n"
	result = result.."function identWrap(typ,str)\n"
	result = result..showIndent(1).."arg = initWrap(str)\n"
	result = result..showIndent(1).."if (arg == nil) or not (arg[\"typ\"] == typ) then return -1 end\n"
	result = result..showIndent(1).."return arg[\"idx\"]\n"
	result = result.."end"
	return result
end
args = nil
if (arg[2] ~= nil) then
	args = {}
	for line in io.lines(arg[2]) do
		local deps = line
		while (1) do
			local word,rest = string.match(deps," *([%w]+)(.*)")
			if word == nil then break end
			if string.match(word,"..*Type") then args = nil; break end
			if string.match(word,"..*Field") then args = nil; break end
			if string.match(word,"..*Subtype") then args = nil; break end
			args[word] = true
			deps = rest
		end
	end
end
base,ext = string.match(arg[1],"([%w.]*)(%.[%w]*)")
file = io.open(base..ext, "w")
if (base and ext and ext == ".h") then
	file:write(showTypeH().."\n")
end
if (base and ext and ext == ".c") then
	file:write(showTypeC(args).."\n")
end
if (base and ext and ext == ".hs") then
	file:write(showTypeHs(args).."\n")
end
if (base and ext and ext == ".lua") then
	file:write(showTypeLua().."\n")
end
file:close()
